# .NET Core Concepts (Summary)

This article outlines the major .NET Core concepts, which are used in advanced .NET applications troubleshooting and analysis.

## Concepts

* [Common Intermediate Language (CIL)](https://en.wikipedia.org/wiki/Common_Intermediate_Language): Common Intermediate Language (CIL) - also know as Microsoft Intermediate Language (MSIL) - is an intermediate language defined within the [Common Language Infrastructure (CLI)](https://en.wikipedia.org/wiki/Common_Language_Infrastructure) specification. CIL instructions are compiled into machine (native) code and executed by a runtime environment such as the Common Language Runtime (CLR). [.NET Compiler Platform (Roslyn)](https://github.com/dotnet/roslyn) is the Microsoft provided platform for compiling C# source code to CIL bytecode.
* [Common Language Runtime (CLR)](https://en.wikipedia.org/wiki/Common_Language_Runtime): Common Language Runtime (CLR) is the Virtual Execution System (VES) component of the CLI. It manages the loading and execution of .NET applications. The CLR provides various application services - Just In Time (JIT) Compilation, Dynamic Profile Guided Optimization (PGO), Memory Management, Garbage Collection (GC), Type Safety, Exception Handling, Thread Management and Security.
* [Base Class Library (BCL)](https://en.wikipedia.org/wiki/Standard_Libraries_(CLI)#Base_Class_Library): Base Class Library (BCL) is part of the CLI Standard Libraries specification. The BCL defines all basic types used throughout .NET - Object class (reference values), ValueType class (value types), primitive types (bool, int, string, etc.), arrays, exceptions, delegates, attributes, container types (hash tables, dictionaries, lists, queues, stacks) and generic types. The BCL also provides common functions such as IO access (stream, file), text handling (encoding, regular expressions) and multi-threading.
* Just In Time (JIT) Compilation: JIT is the process of compiling CIL code into native code by the CLR at run time.
* Dynamic Profile Guided Optimization (PGO): Dynamic PGO is a JIT compiler optimization component that collects application data at runtime, which is then used for post-JIT recompilation.
* Data Access Component (DAC): DAC is a debugging interface, which provides access to internal CLR structures (e.g. managed memory, managed code, GC information).
* Application Domain: An application domain provides an isolation boundary for security and reliability. Application domains are created by the runtime host. There are two types of application domains in .NET Core - System Domain and Default Domain. The System Domain is used for internal CLR structures including string interning. The Default Domain contains the managed heaps and assemblies.
* Assembly: An assembly consists of manifest and one or more modules deployed as a unit.
* Assembly Manifest: The manifest contains assembly metadata - assembly version, publisher, culture, strong name (if the assembly is signed), publicly exported type list, module list and referenced assembly list.
* Module: A module is a portable executable file (e.g. DLL or EXE). It consisting of one or more classes and/or interfaces. Each class/interface is part of a namespace. A module can contain multiple namespaces and a namespace may span multiple modules.
* Metadata Table: The Metadata Table defines various type system metadata elements contained in a module. There are various metadata types - Module, Type reference, Type definition, Field definition, Method definition, Parameter definition, Interface implementation, Member reference, Custom attribute, Permission, Signature, Event, Property, Module reference, Type specification, Assembly, Assembly reference, File, Exported type, Manifest resource, Generic parameter, Method specification, Generic parameter constraint. There are several tools that allow for viewing the metadata information ([dnSpy](https://github.com/dnSpyEx/dnSpy), [ILSpy](https://github.com/icsharpcode/ILSpy)).
* Metadata Token (mdToken): The Metadata Token is a reference to Metadata Table item. The token consists of table reference and table index values.
* Class Loader: The Class Loader is responsible for loading assembly types from metadata streams and constructing the EEClass and MethodTable structures.
* Loader Heap: Loader Heap is a collection of heaps, which contain various CLR runtime and optimization artifacts. High Frequency Heap contains MethodTable, MethodDesc, FieldDescs and Interface Map instances. Low Frequency Heap contains EEClass, Class Loader and Class Loader lookup tables instances. Stub Heap contains COM wrapper calls and P/Invoke artifacts.
* Execution Engine Class (EEClass): The EEClass structure is created by the Class Loader from metadata before the MethodTable is laid out. This structure points to the corresponding type assembly.
* Method Table (MethodTable): There is single MethodTable instance for each declared type. All object instances of the same type will point to the same MethodTable. The MethodTable structure contains information about the kind of type (interface, abstract class, concrete class, COM Wrapper and proxy), static fields, number of interfaces implemented, Interface Vtable Map, interface map for method dispatch, the number of slots in the method table and a table of slots that point to method implementations and MethodDesc. The MethodTable contains a pointer to EEClass.
* Reference Type: Reference type is a type that stores reference to its data. Common reference types are: Class, Generic Class, Anonymous Type, Array, String, Interface, Delegate, Attribute and Exception.
* Value Type: Value type is a type that directly contains its data. Common value types are: Primitive (bool, int, string), Structure (struct), Enumeration (enum), Nullable Value Types and Value Tuple.
* Managed Heap: Managed heap is dynamic memory region managed by the CLR. There can be multiple managed heaps, depending on the GC mode: single (workstation mode), multiple (server mode, based on the number of logical CPU cores). The following are the managed heap segment types: Small Object Heap (SOH) - contains GC Generation 0/1/2 objects, Large Object Heap (LOH) - contains large (85,000) objects, Pinned Object Heap (POH) - contains pinned objects.
* Managed Heap Segment: Each type of Managed Heap consists of one or more physical memory regions called Managed Heap Segments. The first SOH segment is called Ephemeral Segment, which hold GC Generation 0/1 (and optionally Generation 2) objects. All other SOH and LOH segments contain GC Generation 2 objects only.
* Object Reference (ObjectRef): The Object Reference is a pointer to the TypeHandle field in a ObjectInstance memory structure.
* Object Instance (ObjectInstance): The Object Instance is a reference type memory structure stored in a managed heap. The ObjectInstance contains Object Header, TypeHandle and instance field data. The minimum ObjectInstance size is 12 bytes (32-bit platform) or 24 bytes (64-bit platform).
* Object Header: The Object Header is empty or contains either of the following: object instance lock (1-based Sync Block Table index), hash code or GC runtime information.
* Type Handle (TypeHandle): The Type Handle is a pointer to MethodTable instance.
* Method Descriptor (MethodDesc): The Method Descriptor represents CLR method implementation. It contains a pointer to the method CIL. Once the method is JIT compiled, it also contains native code reference.
* Method Dispatch: Method dispatch is a method invocation component. The method dispatch types are: Direct (instance method call), Interface Based (uses Interface Vtable Map and slot) and Virtual (uses fixed method slot number).
* Garbage Collector (GC): Garbage Collector is the component responsible for allocating and releasing managed memory. There are three types of GC Generations: Generations 0 (short-lived objects), Generations 1 (GC promoted short-lived objects), Generations 2 (long-lived objects). There are three GC modes - Workstation, Server and Background. The Garbage Collection process goes through several phases - Mark, Plan, Sweep and Compact.
* GC Root: A GC Root is used to determine if an object is reachable (live) or not (subject to garbage collection). The GC Root is the top-level node in a graph of reachable objects. There are several types of GC Roots - local stack variables, local register variables, static fields, GC handles and finalize queue. The GC uses other CLR components (e.g. JIT Compiler, Stack Walker) to source the the GC Roots.
* Weak Reference (Weak Handle): The Weak Reference is an ObjectRef instance, but it is not treated as GC Root. A Weak Reference does not make an object reachable.
* GCInfo: The GCInfo structure contains GC specific information for particular object instance. It contains all GC safe points along with their corresponding live stack roots.
* Finalization: Finalization is a CLR mechanism that allows for native resource cleanup during GC. For each class with a finalizer (`Finalize()` method, class destructor - `~Class()`), a Finalize Queue entry is created. Once an object with finalizer becomes unreachable it is moved from the Finalize Queue to the F-Reachable Queue. Entries on the F-Reachable Queue are used as GC Roots and processed by the GC on a separate Finalize Thread outside of the regular garbage collection phases.
* Sync Block (SyncBlk): The Sync Block is a structure, which contains various synchronization information such as number of Monitors held, number of lock acquisition times by the same thread and owning thread.
* Sync Block Table: The Sync Block Table is a list of Weak Reference and Sync Block (SyncBlk) pointer items. The Weak Reference maintains a reference to the original object.
* Thin Lock: The Thin Lock is an alternative mechanism for more efficient lock management. It can be used instead of SyncBlk. In the case of Thin Lock the owning Thread ID is stored in the Object Header and no SyncBlk instance is created.
* .ctor: Object constructor to initialize object instance.
* .cctor: Class constructor to initialize static fields.
* Thread Pool: The Thread Pool is a CLR component, which manages multiple threads. its functionality is available through the `System.Threading.ThreadPool` class. Tasks can be queued using the `ThreadPool.QueueUserWorkItem()` method.
* Thread Synchronization Primitives: The thread synchronization primitives are BCL-provided types for synchronized access to a shared resource or coordinate thread interaction. The primitives are - `Monitor` (lock), `System.Threading.Lock`, `WaitHandle`, `Mutex`, `Semaphore`, `SemaphoreSlim`, `EventWaitHandle`, `AutoResetEvent`, `ManualResetEvent`, `ManualResetEventSlim`, `SpinLock`, `SpinWait`, `ReaderWriterLock`, `ReaderWriterLockSlim`, `CountdownEvent`, `Barrier`, `Interlocked`, `ConcurrentDictionary`, `ConcurrentQueue`, `Task`, `Task<T>`, `ValueTask`, `TaskCompletionSource<T>` and `System.Threading.Channels`.
* Pinning: Pinning applies to managed heap variables, which cannot be moved during the GC compact phase.
* String Interning: String Interning is an optimization method for string literals to prevent duplicates. It is based on String Literal Map in native heap that contains hashes and references to entries in the Large Heap Handle Table (String Intern Pool) which in turn contains references to string objects in SOH/LOH heaps.

## References

* Specific concept articles will be available soon.

## Attributes

* Category: .NET Concepts
* Tags: .NET Core, .NET Concepts, Linux