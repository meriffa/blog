# .NET Core Concepts (Method Dispatch)

This article builds on [.NET Core Concepts](./.NET%20Core%20Concepts%20(Summary).md) and provides further details regarding various method dispatch types in a C# application.

The following are the types of C# methods covered in this article:

* Static Methods
* Non-Virtual Methods
* Non-Virtual Replace Methods
* Virtual Methods
* Abstract Implementation Methods
* Interface Virtual Methods (Default Interface Methods)
* Interface Abstract Implementation Methods
* Interface Non-Virtual (Sealed) Methods
* Interface Static Virtual Methods
* Interface Static Abstract Implementation Methods
* Interface Static Non-Virtual (Sealed) Methods
* Generic Methods

## Prerequisites

In order to illustrate the various method dispatch types in C#, let's review the following code fragment:

```
private interface IInterfaceBase
{

    [MethodImpl(MethodImplOptions.NoInlining)]
    string MethodInterfaceVirtual() => "MethodInterfaceVirtual()";

    string MethodInterfaceAbstract();

    [MethodImpl(MethodImplOptions.NoInlining)]
    sealed string MethodInterfaceSealed() => $"{MethodInterfaceVirtual()}:Sealed";

    [MethodImpl(MethodImplOptions.NoInlining)]
    static virtual string MethodInterfaceStaticVirtual() => "MethodInterfaceStaticVirtual()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    static abstract string MethodInterfaceStaticAbstract();

    [MethodImpl(MethodImplOptions.NoInlining)]
    static sealed string MethodInterfaceStaticSealed() => "MethodInterfaceStaticSealed()";

}

private abstract class ClassBase
{

    private readonly string methodNonVirtual = "MethodNonVirtual()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static string MethodStatic() => "MethodStatic()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public string MethodNonVirtual() => methodNonVirtual;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public virtual string MethodVirtual() => "MethodVirtual()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public abstract string MethodAbstract();

}

private class ClassDerived : ClassBase, IInterfaceBase
{

    private readonly string methodNonVirtual = "MethodNonVirtualNew()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public new string MethodNonVirtual() => methodNonVirtual;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string MethodVirtual() => "MethodVirtualOverride()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string MethodAbstract() => "MethodAbstract()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public string MethodInterfaceAbstract() => "MethodInterfaceAbstract()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static string MethodInterfaceStaticAbstract() => "MethodInterfaceStaticAbstract()";

}

private class ClassGeneric<T> : ClassDerived
{

    private readonly string methodGeneric = "MethodGeneric<{0}>()";

    [MethodImpl(MethodImplOptions.NoInlining)]
    public string MethodGeneric() => string.Format(methodGeneric, typeof(T).Name.ToString());

}

protected override void Execute()
{
    var instanceInt = new ClassGeneric<int>();
    var instanceString = new ClassGeneric<string>();
    var instanceObject = new ClassGeneric<MethodDispatchController>();
    displayService.WriteInformation(MethodStatic());
    displayService.WriteInformation(MethodNonVirtualBase(instanceObject));
    displayService.WriteInformation(MethodNonVirtualDerived(instanceObject));
    displayService.WriteInformation(MethodVirtual(instanceObject));
    displayService.WriteInformation(MethodAbstract(instanceObject));
    displayService.WriteInformation(MethodInterfaceVirtual(instanceObject));
    displayService.WriteInformation(MethodInterfaceAbstract(instanceObject));
    displayService.WriteInformation(MethodInterfaceSealed(instanceObject));
    displayService.WriteInformation(MethodInterfaceStaticVirtual<ClassGeneric<MethodDispatchController>>());
    displayService.WriteInformation(MethodInterfaceStaticAbstract<ClassGeneric<MethodDispatchController>>());
    displayService.WriteInformation(MethodInterfaceStaticSealed());
    displayService.WriteInformation(MethodGeneric(instanceObject));
    displayService.WriteInformation(MethodGeneric(instanceString));
    displayService.WriteInformation(MethodGeneric(instanceInt));
    displayService.Wait();
}

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodStatic() => ClassBase.MethodStatic();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodNonVirtualBase(ClassBase instance) => instance.MethodNonVirtual();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodNonVirtualDerived(ClassDerived instance) => instance.MethodNonVirtual();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodVirtual(ClassBase instance) => instance.MethodVirtual();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodAbstract(ClassBase instance) => instance.MethodAbstract();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceVirtual(IInterfaceBase instance) => instance.MethodInterfaceVirtual();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceAbstract(IInterfaceBase instance) => instance.MethodInterfaceAbstract();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceSealed(IInterfaceBase instance) => instance.MethodInterfaceSealed();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceStaticVirtual<T>() where T : IInterfaceBase => T.MethodInterfaceStaticVirtual();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceStaticAbstract<T>() where T : IInterfaceBase => T.MethodInterfaceStaticAbstract();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodInterfaceStaticSealed() => IInterfaceBase.MethodInterfaceStaticSealed();

[MethodImpl(MethodImplOptions.NoInlining)]
private static string MethodGeneric<T>(ClassGeneric<T> instance) => instance.MethodGeneric();
```

The sample code contains three classes (`ClassBase`, `ClassDerived` and `ClassGeneric<T>`) and one interface (`IInterfaceBase`) that define different types of methods. The `Execute()` method creates three object instances (`ClassGeneric<int>`, `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>()`), which are passed as parameters to the static methods that call the different class and interface methods.

All methods are decorated with `[MethodImpl(MethodImplOptions.NoInlining)]` attribute to show the different method dispatch types without being affected by method inlining optimization.

Before we run the sample code, we set the following configuration options:

```
export DOTNET_JITMinOpts=1
export DOTNET_TieredCompilation=0
export DOTNET_TC_UseCallCountingStubs=0
```

These options set Minimal Optimizations and turn off Tiered Compilation and call counting stubs, which also affect the method dispatch by adding additional levels of indirection.

Once we run the sample code, we need to take a core dump using `createdump` after all methods have been JIT-compiled and load it into [LLDB](https://lldb.llvm.org/). For more details, see [Create .NET Core Dumps On Linux](/Resources/Articles/Prerequisites/Create%20.NET%20Core%20Dumps%20On%20Linux.md) and [Load .NET Core Dumps In LLDB On Linux](/Resources/Articles/Prerequisites/Load%20.NET%20Core%20Dumps%20In%20LLDB%20On%20Linux.md).

## Static, Non-Virtual, Non-Virtual Replace, Interface Non-Virtual and Interface Static Non-Virtual Method Dispatch

The method dispatch for static, non-virtual, non-virtual replace ([new](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/new-modifier)), interface non-virtual ([sealed](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/sealed)) and interface static non-virtual methods uses a call dispatch pointer mechanism. To view this type of method dispatch, we use the steps below.

First, we get the `MethodDispatchController` class MethodTable reference:

```name2ee ByteZoo.Blog.App.dll!ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController```

Output:
```
Module:      00007f87586b62d8
Assembly:    ByteZoo.Blog.App.dll
Token:       0000000002000025
MethodTable: 00007f8759167868
EEClass:     00007f8759167868
Name:        ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController
```

> [!NOTE]
> The MethodTable value in this case is `00007f8759167868`. The `MethodDispatchController` class contains the main `Execute()` method, sample classes, sample interface and static test methods.

Next, we get the `MethodStatic()` MethodDescriptor:

```dumpmt -md 00007f8759167868```

Output:
```
Canonical MethodTabl 00007F8759167868
Module:              00007F87586B62D8
Name:                ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController
...
           Entry       MethodDesc    JIT Slot             Name
...
00007F87595E3228 00007F87591676A0    JIT 000000000000000A ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodStatic()
00007F87595E3240 00007F87591676C0    JIT 000000000000000B ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodNonVirtualBase(ClassBase)
00007F87595E3258 00007F87591676E0    JIT 000000000000000C ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodNonVirtualDerived(ClassDerived)
...
00007F87595E32D0 00007F8759167780    JIT 0000000000000011 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceSealed(IInterfaceBase)
00007F87595E32E8 00007F87591677F0    JIT 0000000000000012 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceStaticSealed()
```

> [!NOTE]
> The MethodDescriptor value in this case is `00007F87591676A0`.

Using the `MethodStatic()` MethodDescriptor we display the method assembly code:

```clru 00007F87591676A0```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodStatic()
...
00007f8758668480 55                   push    rbp
00007f8758668481 488bec               mov     rbp, rsp
00007f8758668484 ff15beeef700         call    qword ptr [rip + 0xf7eebe]
00007f875866848a 90                   nop     
00007f875866848b 5d                   pop     rbp
00007f875866848c c3                   ret
```

Next, we get the call dispatch pointer address from the `MethodStatic()` RIP-relative `call` instruction as follows:

```memory read -s8 -fX 0x00007f875866848a+0xf7eebe -c 1```

Output:
```
0x7f87595e7348: 0x00007F87586684B0
```

Once we have the call dispatch pointer value, we can display the target method using:

```clru 0x00007F87586684B0```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassBase.MethodStatic()
...
>>> 00007f87586684b0 55                   push    rbp
00007f87586684b1 488bec               mov     rbp, rsp
00007f87586684b4 48b880f19454877f0000 movabs  rax, 0x7f875494f180
00007f87586684be 5d                   pop     rbp
00007f87586684bf c3                   ret
```

This type of method dispatch shows that the static `MethodStatic()` method calls the class `ClassBase.MethodStatic()` static method using a call dispatch pointer at address `0x7f87595e7348`.

If we repeat the same procedure for non-virtual (`MethodNonVirtualBase()`), non-virtual replace (`MethodNonVirtualDerived()`), interface non-virtual (`MethodInterfaceSealed()`) and interface static non-virtual (`MethodInterfaceStaticSealed()`) methods, we get similar results:

Non-Virtual (`MethodNonVirtualBase()`):

```
clru 00007F87591676C0
memory read -s8 -fX 00007f87586684fa+0xf7ee66 -c 1
clru 0x00007F8758668520
```

Output:
```
...
00007f87586684f4 ff1566eef700         call    qword ptr [rip + 0xf7ee66]
00007f87586684fa 90                   nop     
...
0x7f87595e7360: 0x00007F8758668520
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassBase.MethodNonVirtual()
...
```

Non-Virtual Replace (`MethodNonVirtualDerived()`):

```
clru 00007F87591676E0
memory read -s8 -fX 00007f875866856a+0xf7ee0e -c 1
clru 0x00007F8758668590
```

Output:
```
...
00007f8758668564 ff150eeef700         call    qword ptr [rip + 0xf7ee0e]
00007f875866856a 90                   nop     
...
0x7f87595e7378: 0x00007F8758668590
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodNonVirtual()
...
```

Interface Non-Virtual (`MethodInterfaceSealed()`):

```
clru 00007F8759167780
memory read -s8 -fX 0x00007f87586687da+0xf7ec16 -c 1
clru 0x00007F8758668800
```

Output:
```
...
00007f87586687d4 ff1516ecf700         call    qword ptr [rip + 0xf7ec16]
00007f87586687da 90                   nop
...
0x7f87595e73f0: 0x00007F8758668800
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+IInterfaceBase.MethodInterfaceSealed()
...
```

Interface Static Non-Virtual (`MethodInterfaceStaticSealed()`):

```
clru 00007F87591677F0
memory read -s8 -fX 0x00007f87586689ca+0xf7ea6e -c 1
clru 0x00007F87586689F0
```

Output:
```
...
00007f87586689c4 ff156eeaf700         call    qword ptr [rip + 0xf7ea6e]
00007f87586689ca 90                   nop
...
0x7f87595e7438: 0x00007F87586689F0
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+IInterfaceBase.MethodInterfaceStaticSealed()
...
```

## Virtual and Abstract Implementation Method Dispatch

The method dispatch for virtual and abstract implementation methods uses a [VTable](https://en.wikipedia.org/wiki/Virtual_method_table) Lookup mechanism. The steps below outline this type of method dispatch.

First, we get the `MethodVirtual()` MethodDescriptor:

```dumpmt -md 00007f8759167868```

Output:
```
Canonical MethodTabl 00007F8759167868
Module:              00007F87586B62D8
Name:                ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController
...
           Entry       MethodDesc    JIT Slot             Name
...
00007F87595E3270 00007F8759167700    JIT 000000000000000D ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodVirtual(ClassBase)
00007F87595E3288 00007F8759167720    JIT 000000000000000E ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodAbstract(ClassBase)...
...
```

> [!NOTE]
> The MethodDescriptor value in this case is `00007F8759167700`.

Using the `MethodVirtual()` MethodDescriptor, we display the method assembly code:

```clru 00007F8759167700```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodVirtual(ClassBase)
...
00007f87586685c0 55                   push    rbp
00007f87586685c1 4883ec10             sub     rsp, 0x10
00007f87586685c5 488d6c2410           lea     rbp, [rsp + 0x10]
00007f87586685ca 48897df8             mov     qword ptr [rbp - 0x8], rdi
00007f87586685ce 488b7df8             mov     rdi, qword ptr [rbp - 0x8]
00007f87586685d2 488b45f8             mov     rax, qword ptr [rbp - 0x8]
00007f87586685d6 488b00               mov     rax, qword ptr [rax]
00007f87586685d9 488b4040             mov     rax, qword ptr [rax + 0x40]
00007f87586685dd ff5020               call    qword ptr [rax + 0x20]
00007f87586685e0 90                   nop     
00007f87586685e1 4883c410             add     rsp, 0x10
00007f87586685e5 5d                   pop     rbp
00007f87586685e6 c3                   ret
```

Next, we need to get the `ClassDerived` class MethodTable using:

```name2ee ByteZoo.Blog.App.dll!ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived```

Output:
```
Module:      00007f87586b62d8
Assembly:    ByteZoo.Blog.App.dll
Token:       000000000200006A
MethodTable: 00007f87594b9b98
EEClass:     00007f87594b9b98
Name:        ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived
```

> [!NOTE]
> The MethodTable value in this case is `00007F87594B9B98`.

Using the `ClassDerived` MethodTable, we can get the class VTable address as follows:

```memory read -s8 -fX 0x00007F87594B9B98+0x40 -c 1```

Output:
```
0x7f87594b9bd8: 0x00007F87594B9BF0
```

> [!NOTE]
> To get the VTable address, we use the MethodTable (`00007F87594B9B98`) as base and `mov rax, qword ptr [rax + 0x40]` as offset (`0x40`) inside the MethodTable structure.

Once we have the VTable address (`0x00007F87594B9BF0`), we get the method slot pointer using:

```memory read -s8 -fX 0x00007F87594B9BF0+0x20 -c 1```

Output:
```
0x7f87594b9c10: 0x00007F8758668600
```

> [!NOTE]
> To get the method slot pointer, we use the VTable address (`0x00007F87594B9BF0`) as base and the slot index (`0000000000000004`) multiplied by pointer size (`IntPtr.Size`, 8 bytes) as offset (`call qword ptr [rax + 0x20]`).

Once we have the method slot pointer, we can display the target method using:

```clru 0x00007F8758668600```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodVirtual()
...
>>> 00007f8758668600 55                   push    rbp
00007f8758668601 4883ec10             sub     rsp, 0x10
00007f8758668605 488d6c2410           lea     rbp, [rsp + 0x10]
00007f875866860a 48897df8             mov     qword ptr [rbp - 0x8], rdi
00007f875866860e 48b8b8f19454877f0000 movabs  rax, 0x7f875494f1b8
00007f8758668618 4883c410             add     rsp, 0x10
00007f875866861c 5d                   pop     rbp
00007f875866861d c3                   ret
```

This type of method dispatch shows that the static `MethodVirtual()` method calls the class `ClassDerived.MethodVirtual()` method using VTable slot pointer.

If we repeat the same procedure for an abstract implementation (`MethodAbstract()`) method, we get similar results:

```
clru 00007F8759167720
name2ee ByteZoo.Blog.App.dll!ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived
memory read -s8 -fX 0x00007F87594B9B98+0x40 -c 1
memory read -s8 -fX 0x00007F87594B9BF0+0x28 -c 1
clru 0x00007F8758668680
```

Output:
```
...
00007f8758668659 488b4040             mov     rax, qword ptr [rax + 0x40]
00007f875866865d ff5028               call    qword ptr [rax + 0x28]
...
0x7f87594b9bd8: 0x00007F87594B9BF0
0x7f87594b9c18: 0x00007F8758668680
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodAbstract()
...
```

## Interface Non-Static (Virtual, Abstract) Method Dispatch

The method dispatch for interface non-static (virtual, abstract) methods uses a [Virtual Stub Dispatch (VSD)](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/virtual-stub-dispatch.md) mechanism. The steps below outline this type of method dispatch.

First, we get the `MethodInterfaceVirtual()` MethodDescriptor:

```dumpmt -md 00007f8759167868```

Output:
```
Canonical MethodTabl 00007F8759167868
Module:              00007F87586B62D8
Name:                ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController
...
           Entry       MethodDesc    JIT Slot             Name
...
00007F87595E32A0 00007F8759167740    JIT 000000000000000F ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceVirtual(IInterfaceBase)
00007F87595E32B8 00007F8759167760    JIT 0000000000000010 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceAbstract(IInterfaceBase)
...
```

> [!NOTE]
> The MethodDescriptor value in this case is `00007F8759167740`.

Using the `MethodInterfaceVirtual()` MethodDescriptor, we display the method assembly code:

```clru 00007F8759167740```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceVirtual(IInterfaceBase)
...
00007f87586686c0 55                   push    rbp
00007f87586686c1 4883ec10             sub     rsp, 0x10
00007f87586686c5 488d6c2410           lea     rbp, [rsp + 0x10]
00007f87586686ca 48897df8             mov     qword ptr [rbp - 0x8], rdi
00007f87586686ce 488b7df8             mov     rdi, qword ptr [rbp - 0x8]
00007f87586686d2 49bb980f6757877f0000 movabs  r11, 0x7f8757670f98
00007f87586686dc 41ff13               call    qword ptr [r11]
00007f87586686df 90                   nop     
00007f87586686e0 4883c410             add     rsp, 0x10
00007f87586686e4 5d                   pop     rbp
00007f87586686e5 c3                   ret
```

Next, we get the indirection cell pointer from the `MethodInterfaceVirtual()` method `call qword ptr [r11]` instruction as follows:

```memory read -s8 -fX 0x7f8757670f98 -c 1```

Output:
```
0x7f8757670f98: 0x00007F8758664190
```

Using the indirection cell pointer, we display the indirection cell function as follows:

```disassemble -s 0x00007F8758664190 -c 5```

Output:
```
    0x7f8758664190: nop    
    0x7f8758664191: movabs rax, 0x8700000000
    0x7f875866419b: push   rax
    0x7f875866419c: movabs rax, 0x7f87d6ac3c04
    0x7f87586641a6: jmp    rax
```

> [!NOTE]
> The indirection cell function also contains the Dispatch Token (`0x8700000000`). The Dispatch Token contains Type ID (Interface ID) and Slot Index values. The slot index value is `0000` (16-bit) in this case.

From the indirection cell function, we display the VSD stub using the VSD stub address (`0x7f87d6ac3c04`) as follows:

```disassemble -s 0x7f87d6ac3c04 -c 51```

Output:
```
libcoreclr.so`ResolveWorkerAsmStub:
    0x7f87d6ac3c04 <+0>:   push   rbx
    0x7f87d6ac3c05 <+1>:   push   r15
    0x7f87d6ac3c07 <+3>:   push   r14
    0x7f87d6ac3c09 <+5>:   push   r13
    0x7f87d6ac3c0b <+7>:   push   r12
    0x7f87d6ac3c0d <+9>:   push   r9
    0x7f87d6ac3c0f <+11>:  push   r8
    0x7f87d6ac3c11 <+13>:  push   rcx
    0x7f87d6ac3c12 <+14>:  push   rdx
    0x7f87d6ac3c13 <+15>:  push   rsi
    0x7f87d6ac3c14 <+16>:  push   rdi
    0x7f87d6ac3c15 <+17>:  mov    rdx, qword ptr [rsp + 0x58]
    0x7f87d6ac3c1a <+22>:  mov    qword ptr [rsp + 0x58], rbp
    0x7f87d6ac3c1f <+27>:  lea    rbp, [rsp + 0x58]
    0x7f87d6ac3c24 <+32>:  lea    rsp, [rsp - 0x88]
    0x7f87d6ac3c2c <+40>:  movdqa xmmword ptr [rsp], xmm0
    0x7f87d6ac3c31 <+45>:  movdqa xmmword ptr [rsp + 0x10], xmm1
    0x7f87d6ac3c37 <+51>:  movdqa xmmword ptr [rsp + 0x20], xmm2
    0x7f87d6ac3c3d <+57>:  movdqa xmmword ptr [rsp + 0x30], xmm3
    0x7f87d6ac3c43 <+63>:  movdqa xmmword ptr [rsp + 0x40], xmm4
    0x7f87d6ac3c49 <+69>:  movdqa xmmword ptr [rsp + 0x50], xmm5
    0x7f87d6ac3c4f <+75>:  movdqa xmmword ptr [rsp + 0x60], xmm6
    0x7f87d6ac3c55 <+81>:  movdqa xmmword ptr [rsp + 0x70], xmm7
    0x7f87d6ac3c5b <+87>:  lea    rdi, [rsp + 0x88]
    0x7f87d6ac3c63 <+95>:  mov    rsi, r11
    0x7f87d6ac3c66 <+98>:  mov    rcx, rsi
    0x7f87d6ac3c69 <+101>: and    rcx, 0x7
    0x7f87d6ac3c6d <+105>: sub    rsi, rcx
    0x7f87d6ac3c70 <+108>: call   0x7f87d68e74f0            ; ::VSD_ResolveWorker(TransitionBlock *, TADDR, size_t, UINT_PTR) at virtualcallstub.cpp:1287
    0x7f87d6ac3c75 <+113>: movdqa xmm0, xmmword ptr [rsp]
    0x7f87d6ac3c7a <+118>: movdqa xmm1, xmmword ptr [rsp + 0x10]
    0x7f87d6ac3c80 <+124>: movdqa xmm2, xmmword ptr [rsp + 0x20]
    0x7f87d6ac3c86 <+130>: movdqa xmm3, xmmword ptr [rsp + 0x30]
    0x7f87d6ac3c8c <+136>: movdqa xmm4, xmmword ptr [rsp + 0x40]
    0x7f87d6ac3c92 <+142>: movdqa xmm5, xmmword ptr [rsp + 0x50]
    0x7f87d6ac3c98 <+148>: movdqa xmm6, xmmword ptr [rsp + 0x60]
    0x7f87d6ac3c9e <+154>: movdqa xmm7, xmmword ptr [rsp + 0x70]
    0x7f87d6ac3ca4 <+160>: lea    rsp, [rsp + 0x88]
    0x7f87d6ac3cac <+168>: pop    rdi
    0x7f87d6ac3cad <+169>: pop    rsi
    0x7f87d6ac3cae <+170>: pop    rdx
    0x7f87d6ac3caf <+171>: pop    rcx
    0x7f87d6ac3cb0 <+172>: pop    r8
    0x7f87d6ac3cb2 <+174>: pop    r9
    0x7f87d6ac3cb4 <+176>: pop    r12
    0x7f87d6ac3cb6 <+178>: pop    r13
    0x7f87d6ac3cb8 <+180>: pop    r14
    0x7f87d6ac3cba <+182>: pop    r15
    0x7f87d6ac3cbc <+184>: pop    rbx
    0x7f87d6ac3cbd <+185>: pop    rbp
    0x7f87d6ac3cbe <+186>: jmp    rax
```

> [!NOTE]
> The output shows the [Generic Resolver](https://github.com/dotnet/coreclr/blob/master/Documentation/botr/virtual-stub-dispatch.md#generic-resolver) function of the VSD component that calls the `VSD_ResolveWorker()` function. If you encounter `___lldb_unnamed_symbol`, run `loadsymbols` or make sure you have proper symbols loaded.

The VSD component details are outside the scope of this article. For more details, see [virtualcallstub.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/virtualcallstub.h) and [virtualcallstub.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/virtualcallstub.cpp).

## Generic Method Dispatch

The method dispatch for generic methods uses a [Shared Generics Design](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/shared-generics.md) mechanism. The steps below outline this type of method dispatch.

First, we get the `Execute()` MethodDescriptor:

```dumpmt -md 00007f8759167868```

Output:
```
Canonical MethodTabl 00007F8759167868
Module:              00007F87586B62D8
Name:                ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController
...
           Entry       MethodDesc    JIT Slot             Name
...
00007F8758667F70 00007F8759167688    JIT 0000000000000005 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.Execute()
...
```

Next, we look at the `MethodGeneric<T>()` static method invocation inside the `Execute()` method:

```clru 00007F8759167688```

Output:
```
...
/home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/Controllers/Concepts/MethodDispatchController.cs @ 198:
00007f875866824e 488b45f8             mov     rax, qword ptr [rbp - 0x8]
00007f8758668252 488b4010             mov     rax, qword ptr [rax + 0x10]
00007f8758668256 48898568ffffff       mov     qword ptr [rbp - 0x98], rax
00007f875866825d 488b75e0             mov     rsi, qword ptr [rbp - 0x20]
00007f8758668261 48bf483a6159877f0000 movabs  rdi, 0x7f8759613a48
00007f875866826b ff1527eff700         call    qword ptr [rip + 0xf7ef27]
00007f8758668271 488985f8feffff       mov     qword ptr [rbp - 0x108], rax
00007f8758668278 488bb5f8feffff       mov     rsi, qword ptr [rbp - 0x108]
00007f875866827f 488bbd68ffffff       mov     rdi, qword ptr [rbp - 0x98]
00007f8758668286 393f                 cmp     dword ptr [rdi], edi
00007f8758668288 ff15f2f1f2ff         call    qword ptr [rip - 0xd0e0e]
...
```

Next, we get the generic call dispatch pointer address from the `MethodDispatchController()` first RIP-relative `call qword ptr [rip + 0xf7ef27]` instruction as follows:

```memory read -s8 -fX 0x00007f8758668271+0xf7ef27 -c 1```

Output:
```
0x7f87595e7198: 0x00007F8758668A20
```

> [!NOTE]
> The second RIP-relative call `call qword ptr [rip - 0xd0e0e]` is a console display call and is not related to this method dispatch.

Once we have the generic call dispatch pointer value, we can display the target method using:

```clru 0x00007F8758668A20```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodGeneric[[System.__Canon, System.Private.CoreLib]](ClassGeneric`1<System.__Canon>)
...
>>> 00007f8758668a20 55                   push    rbp
00007f8758668a21 4883ec10             sub     rsp, 0x10
00007f8758668a25 488d6c2410           lea     rbp, [rsp + 0x10]
00007f8758668a2a 48897df8             mov     qword ptr [rbp - 0x8], rdi
00007f8758668a2e 488975f0             mov     qword ptr [rbp - 0x10], rsi
00007f8758668a32 488b7df0             mov     rdi, qword ptr [rbp - 0x10]
00007f8758668a36 393f                 cmp     dword ptr [rdi], edi
00007f8758668a38 ff1512eaf700         call    qword ptr [rip + 0xf7ea12]
00007f8758668a3e 90                   nop     
00007f8758668a3f 4883c410             add     rsp, 0x10
00007f8758668a43 5d                   pop     rbp
00007f8758668a44 c3                   ret
```

> [!NOTE]
> The output shows the generic JIT-compiled version of the static `MethodGeneric<T>()` method that is used to call the generic class method `ClassGeneric<T>.MethodGeneric()` method.

**There is one important observation in the last step.** There are two different versions of the `MethodGeneric<T>` method. The first version is defined as `MethodGeneric(ClassGeneric``1<!!0>)`. It appears in the `dumpmt -md` output and is not JIT-compiled. The second version is defined as `MethodGeneric[System.__Canon](ClassGeneric``1<System.__Canon>)`, it is JIT-complied and does not appear in the `dumpmt -md` output.

Next, we can dereference the RIP-relative call in the `MethodGeneric<T>()` method using:

```memory read -s8 -fX 0x00007f8758668a3e+0xf7ea12 -c 1```

Output:
```
0x7f87595e7450: 0x00007F8758668A60
```

And then:

```clru 0x00007F8758668A60```

Output:
```
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]].MethodGeneric()
ilAddr is 00007F8754927BFC pImport is 0000000014079280
Begin 00007F8758668A60, size 97

/home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/Controllers/Concepts/MethodDispatchController.cs @ 172:
>>> 00007f8758668a60 55                   push    rbp
00007f8758668a61 4883ec40             sub     rsp, 0x40
00007f8758668a65 488d6c2440           lea     rbp, [rsp + 0x40]
00007f8758668a6a 33c0                 xor     eax, eax
00007f8758668a6c 488945c8             mov     qword ptr [rbp - 0x38], rax
...
00007f8758668af1 4883c440             add     rsp, 0x40
00007f8758668af5 5d                   pop     rbp
00007f8758668af6 c3                   ret
```

If we repeat the same procedure for another generic method (`MethodGeneric<string>()`) that uses reference type as generic parameter the results are identical:

```
clru 00007F8759167688
memory read -s8 -fX 0x00007f87586682b1+0xf7eee7 -c 1
clru 0x00007F8758668A20
memory read -s8 -fX 0x00007f8758668a3e+0xf7ea12 -c 1
clru 0x00007F8758668A60
```

Output:
```
...
00007f87586682ab ff15e7eef700         call    qword ptr [rip + 0xf7eee7]
00007f87586682b1 488985f0feffff       mov     qword ptr [rbp - 0x110], rax
...
0x7f87595e7198: 0x00007F8758668A20
...
00007f8758668a38 ff1512eaf700         call    qword ptr [rip + 0xf7ea12]
00007f8758668a3e 90                   nop     
...
0x7f87595e7450: 0x00007F8758668A60
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]].MethodGeneric()
...
```

The same procedure for another generic method (`MethodGeneric<int>()`) that uses value type as generic parameter the results are slightly different:

```
clru 00007F8759167688
memory read -s8 -fX 0x00007f87586682e7+0xf7eef9 -c 1
clru 0x00007F8758668B10
memory read -s8 -fX 0x00007f8758668b2a+0xf7e986 -c 1
clru 0x00007F8758668B50
```

Output:
```
...
00007f87586682e1 ff15f9eef700         call    qword ptr [rip + 0xf7eef9]
00007f87586682e7 488985e8feffff       mov     qword ptr [rbp - 0x118], rax
...
0x7f87595e71e0: 0x00007F8758668B10
...
00007f8758668b24 ff1586e9f700         call    qword ptr [rip + 0xf7e986]
00007f8758668b2a 90                   nop
...
0x7f87595e74b0: 0x00007F8758668B50
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.Int32, System.Private.CoreLib]].MethodGeneric()
...
>>> 00007f8758668b50 55                   push    rbp
00007f8758668b51 4883ec30             sub     rsp, 0x30
00007f8758668b55 488d6c2430           lea     rbp, [rsp + 0x30]
00007f8758668b5a c4413857c0           vxorps  xmm8, xmm8, xmm8
00007f8758668b5f c57e7f45d0           vmovdqu ymmword ptr [rbp - 0x30], ymm8
00007f8758668b64 33c0                 xor     eax, eax
...
00007f8758668bd6 4883c430             add     rsp, 0x30
00007f8758668bda 5d                   pop     rbp
00007f8758668bdb c3                   ret
```

In this case, there is a third version of the `MethodGeneric<T>()` method. It is defined as `MethodGeneric[System.Int32](ClassGeneric``1<Int32>)`, it is JIT-complied and does not appear in the `dumpmt -md` output. The difference is explained in the next section.

## Canonical Method Tables

Generic classes use an optimization feature called Canonical Method Tables that allows the runtime to re-use generic method implementations for different generic type arguments. This usually applies to reference type generic arguments.

The sample code in this article uses a generic class `ClassGeneric<T>` with three different generic type parameters - `int`, `string` and `MethodDispatchController`. In this case, `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>` will share a single Canonical Method Table and have their own individual Method Tables as well. The reason being is that both `string` and `MethodDispatchController` are reference types.

First, let's review the `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>` MethodTables using:

```dumpheap -stat -type ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric```

Output:
```
Statistics:
          MT Count TotalSize Class Name
7f8759613418     1        40 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric<System.Int32>
7f87596135e8     1        40 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric<System.String>
7f87596136a0     1        40 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric<ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController>
Total 3 objects, 120 bytes
```

For `ClassGeneric<string>` MethodTable we use:

```dumpclass 7f87596135e8```

Output:
```
Class Name:      ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.String, System.Private.CoreLib]]
...
Method Table:    00007f87596135e8
Canonical MethodTable: 00007f8759613520
...
```

And for `ClassGeneric<MethodDispatchController>` MethodTable we use:

```dumpclass 7f87596136a0```

Output:
```
Class Name:      ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController, ByteZoo.Blog.App]]
...
Method Table:    00007f87596136a0
Canonical MethodTable: 00007f8759613520
...
```

The output from both `dumpclass` commands shows that both `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>` classes share a Canonical Method Table (`00007f8759613520`) and have their individual MethodTables (`00007f87596135e8` and `00007f87596136a0` respectively).

Next, we can review the Canonical Method Table class definition:

```dumpclass 00007f8759613520```

Output:
```
Class Name:      ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]]
mdToken:         000000000200006B
File:            /home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/bin/Release/net9.0/ByteZoo.Blog.App.dll
Parent MethodTable: 00007f87594b9b98
Module:          00007f87586b62d8
Method Table:    00007f8759613520
Canonical MethodTable: 00007f8759613520
Class Attributes:    100003  
NumInstanceFields:   3
NumStaticFields:     0
              MT    Field   Offset                 Type VT     Attr            Value Name
00007f87585fbb48  4000122        8        System.String  0 instance           methodNonVirtual
00007f87585fbb48  4000123       10        System.String  0 instance           methodNonVirtual
00007f87585fbb48  4000124       18        System.String  0 instance           methodGeneric
```

> [!NOTE]
> The Canonical Method Table class for both `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>` is defined as `ClassGeneric<System.__Canon>`.

Also, we can review the Canonical Method Table method definitions using:

```dumpmt -md 00007f8759613520```

Output:
```
Canonical MethodTabl 00007F8759613520
Module:              00007F87586B62D8
Name:                ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]]
mdToken:             000000000200006B
File:                /home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/bin/Release/net9.0/ByteZoo.Blog.App.dll
AssemblyLoadContext: Default ALC - The managed instance of this context doesn't exist yet.
BaseSize:            0x28
ComponentSize:       0x0
DynamicStatics:      false
ContainsPointers:    true
Number of Methods:   9
Number of IFaces in IFaceMap: 1
--------------------------------------
MethodDesc Table
           Entry       MethodDesc    JIT Slot             Name
00007F8758590000 00007F8757664870   NONE 0000000000000000 System.Object.Finalize()
00007F87585900A8 00007F8757664888   NONE 0000000000000001 System.Object.ToString()
00007F8758590E70 00007F87576648A0 PreJIT 0000000000000002 System.Object.Equals(System.Object)
00007F8758590E88 00007F87576648F8   NONE 0000000000000003 System.Object.GetHashCode()
00007F8758668600 00007F87594B9AE0    JIT 0000000000000004 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodVirtual()
00007F8758668680 00007F87594B9AF8    JIT 0000000000000005 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodAbstract()
00007F8758668780 00007F87594B9B10    JIT 0000000000000006 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassDerived.MethodInterfaceAbstract()
00007F87595E3210 00007F87596134F0    JIT 0000000000000007 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]]..ctor()
00007F87595E3450 00007F87596134D8    JIT 0000000000000008 ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.__Canon, System.Private.CoreLib]].MethodGeneric()
```

> [!NOTE]
> Canonical Method Table method implementations are shared between `ClassGeneric<string>` and `ClassGeneric<MethodDispatchController>`. We can confirm that by comparing the `MethodDesc` and `Entry` values from `dumpmt -md 7f87596135e8` and `dumpmt -md 7f87596136a0` output.

Next, we can confirm that the `ClassGeneric<int>` class is not using a Canonical Method Table using:

```dumpclass 7f8759613418```

Output:
```
Class Name:      ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController+ClassGeneric`1[[System.Int32, System.Private.CoreLib]]
...
Method Table:    00007f8759613418
Canonical MethodTable: 00007f8759613418
...
```

> [!NOTE]
> The `dumpclass` command output shows that both `Method Table` and `Canonical MethodTable` values are the same (`00007f8759613418`).

## Interface Static (Virtual, Abstract) Method Dispatch

The method dispatch for interface static (virtual, abstract) methods is virtually the same as the [Generic Method Dispatch](#generic-method-dispatch) described above.

For `MethodInterfaceStaticVirtual<T>()` we can use the following:

```
clru 00007F8759167688
memory read -s8 -fX 0x00007f87586681c6+0xf7ef72 -c 1
clru 0x00007F8758668860
```

Output:
```
...
/home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/Controllers/Concepts/MethodDispatchController.cs @ 195:
00007f87586681aa 488b45f8             mov     rax, qword ptr [rbp - 0x8]
00007f87586681ae 488b4010             mov     rax, qword ptr [rax + 0x10]
00007f87586681b2 48894580             mov     qword ptr [rbp - 0x80], rax
00007f87586681b6 48bf18386159877f0000 movabs  rdi, 0x7f8759613818
00007f87586681c0 ff1572eff700         call    qword ptr [rip + 0xf7ef72]
00007f87586681c6 48898510ffffff       mov     qword ptr [rbp - 0xf0], rax
00007f87586681cd 488bb510ffffff       mov     rsi, qword ptr [rbp - 0xf0]
00007f87586681d4 488b7d80             mov     rdi, qword ptr [rbp - 0x80]
00007f87586681d8 393f                 cmp     dword ptr [rdi], edi
00007f87586681da ff15a0f2f2ff         call    qword ptr [rip - 0xd0d60]
...
0x7f87595e7138: 0x00007F8758668860
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceStaticVirtual[[System.__Canon, System.Private.CoreLib]]()
...
>>> 00007f8758668860 55                   push    rbp
00007f8758668861 4883ec30             sub     rsp, 0x30
...
00007f87586688b9 4883c430             add     rsp, 0x30
00007f87586688bd 5d                   pop     rbp
00007f87586688be c3                   ret
```

And for `MethodInterfaceStaticAbstract<T>()` the following:

```
clru 00007F8759167688
memory read -s8 -fX 0x00007f87586681ff+0xf7ef69 -c 1
clru 0x00007F8758668910
```

Output:
```
...
/home/marian/Development/ByteZoo.Blog/Sources/ByteZoo.Blog.App/Controllers/Concepts/MethodDispatchController.cs @ 196:
00007f87586681e0 488b45f8             mov     rax, qword ptr [rbp - 0x8]
00007f87586681e4 488b4010             mov     rax, qword ptr [rax + 0x10]
00007f87586681e8 48898578ffffff       mov     qword ptr [rbp - 0x88], rax
00007f87586681ef 48bf30396159877f0000 movabs  rdi, 0x7f8759613930
00007f87586681f9 ff1569eff700         call    qword ptr [rip + 0xf7ef69]
00007f87586681ff 48898508ffffff       mov     qword ptr [rbp - 0xf8], rax
00007f8758668206 488bb508ffffff       mov     rsi, qword ptr [rbp - 0xf8]
00007f875866820d 488bbd78ffffff       mov     rdi, qword ptr [rbp - 0x88]
00007f8758668214 393f                 cmp     dword ptr [rdi], edi
00007f8758668216 ff1564f2f2ff         call    qword ptr [rip - 0xd0d9c]
...
0x7f87595e7168: 0x00007F8758668910
...
Normal JIT generated code
ByteZoo.Blog.App.Controllers.Concepts.MethodDispatchController.MethodInterfaceStaticAbstract[[System.__Canon, System.Private.CoreLib]]()
...
>>> 00007f8758668910 55                   push    rbp
00007f8758668911 4883ec30             sub     rsp, 0x30
...
00007f8758668969 4883c430             add     rsp, 0x30
00007f875866896d 5d                   pop     rbp
00007f875866896e c3                   ret
```

## References

* [.NET Core Concepts](./.NET%20Core%20Concepts%20(Summary).md)
* [Article Source Code](/Sources)

<!--- Category = .NET Concepts, Tags = .NET Core, .NET Concepts, Linux --->